// Copyright 2024 The TensorStore Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Minimal example demonstrating structured Zarr v3 data reading.
// This example reads the 'foo.zarr' output generated by generate_struct.py
//
// Usage:
//   ./read_foo_zarr --zarr_path=/path/to/foo.zarr

#include <stdint.h>

#include <iostream>
#include <string>

#include "absl/flags/flag.h"
#include "absl/flags/parse.h"
#include "absl/status/status.h"
#include <nlohmann/json.hpp>
#include "tensorstore/array.h"
#include "tensorstore/context.h"
#include "tensorstore/data_type.h"
#include "tensorstore/index.h"
#include "tensorstore/open.h"
#include "tensorstore/open_mode.h"
#include "tensorstore/spec.h"
#include "tensorstore/tensorstore.h"
#include "tensorstore/util/result.h"
#include "tensorstore/util/status.h"

// Internal headers for testing dtype parsing
#include "tensorstore/driver/zarr3/dtype.h"

ABSL_FLAG(std::string, zarr_path,
          "/home/ubuntu/source/tensorstore/foo.zarr",
          "Path to the foo.zarr directory");

namespace {

using ::tensorstore::Index;

// Helper function to read and display data from a tensorstore
absl::Status ReadAndDisplayData(const tensorstore::TensorStore<>& store,
                               const std::string& description) {
  std::cout << "\n=== " << description << " ===" << std::endl;

  // Get array information
  auto domain = store.domain();
  std::cout << "Domain: " << domain << std::endl;
  std::cout << "Data type: " << store.dtype() << std::endl;

  // Read all data
  TENSORSTORE_ASSIGN_OR_RETURN(auto array, tensorstore::Read<tensorstore::zero_origin>(store).result());

  std::cout << "Successfully read array with " << array.num_elements() << " elements" << std::endl;

  // Display first few elements for verification
  auto shape = domain.shape();
  if (shape.size() >= 2) {
    Index rows = std::min(shape[0], Index{5});
    Index cols = std::min(shape[1], Index{5});

    std::cout << "First " << rows << "x" << cols << " elements:" << std::endl;
    for (Index i = 0; i < rows; ++i) {
      for (Index j = 0; j < cols; ++j) {
        // For demonstration, assume we can display as int32
        // In practice, you'd check the actual dtype
        if (store.dtype() == tensorstore::dtype_v<tensorstore::dtypes::int32_t>) {
          const int32_t* data = reinterpret_cast<const int32_t*>(array.data());
          std::cout << data[i * shape[1] + j] << "\t";
        } else {
          std::cout << "[non-int32 data]\t";
        }
      }
      std::cout << std::endl;
    }
  }

  return absl::OkStatus();
}

absl::Status Run(const std::string& zarr_path) {
  std::cout << "=== Structured Zarr v3 Example ===" << std::endl;
  std::cout << "Reading from: " << zarr_path << std::endl;

  auto context = tensorstore::Context::Default();

  // Open the structured Zarr v3 array with field access
  ::nlohmann::json spec = ::nlohmann::json::object();
  spec["driver"] = "zarr3";
  spec["kvstore"] = ::nlohmann::json::object();
  spec["kvstore"]["driver"] = "file";
  spec["kvstore"]["path"] = zarr_path + "/";
  spec["field"] = "field_n";
  // spec["open_as_void"] = true;

  std::cout << spec.dump(4) << std::endl;

  std::cout << "\nOpening structured array..." << std::endl;
  auto open_result = tensorstore::Open(spec, context, tensorstore::OpenMode::open,
                                      tensorstore::ReadWriteMode::read).result();

  if (!open_result.ok()) {
    std::cout << "Failed to open structured array: " << open_result.status() << std::endl;
    return open_result.status();
  }

  auto store = std::move(open_result).value();
  TENSORSTORE_RETURN_IF_ERROR(ReadAndDisplayData(store, "Structured Array"));

  // Demonstrate the new open_as_void feature for raw byte access
  std::cout << "\nDemonstrating open_as_void feature..." << std::endl;

  ::nlohmann::json void_spec = spec;
  void_spec["open_as_void"] = true;
  void_spec.erase("field");
  // void_spec["field"] = "field_2";
  // void_spec.erase("open_as_void");

  std::cout << void_spec.dump(4) << std::endl;

  auto void_open_result = tensorstore::Open(void_spec, context, tensorstore::OpenMode::open,
                                           tensorstore::ReadWriteMode::read).result();

  if (!void_open_result.ok()) {
    std::cout << "Failed to open with open_as_void: " << void_open_result.status() << std::endl;
    return void_open_result.status();
  }

  auto void_store = std::move(void_open_result).value();
  TENSORSTORE_RETURN_IF_ERROR(ReadAndDisplayData(void_store, "Raw Bytes (open_as_void)"));

  std::cout << "\n=== Example completed successfully ===" << std::endl;
  std::cout << "This demonstrates:" << std::endl;
  std::cout << "- Reading structured Zarr v3 arrays" << std::endl;
  std::cout << "- Field-based data access" << std::endl;
  std::cout << "- The new open_as_void option for raw byte access" << std::endl;

  return absl::OkStatus();
}

}  // namespace

int main(int argc, char** argv) {
  absl::ParseCommandLine(argc, argv);

  std::string zarr_path = absl::GetFlag(FLAGS_zarr_path);
  if (zarr_path.empty()) {
    std::cerr << "Error: --zarr_path is required" << std::endl;
    return 1;
  }

  auto status = Run(zarr_path);
  if (!status.ok()) {
    std::cerr << "\nFinal status: " << status << std::endl;
    return 1;
  }

  return 0;
}
